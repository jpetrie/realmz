#include "EventManager.h"

#include <SDL3/SDL_events.h>

#include <cstring>
#include <deque>
#include <phosg/Strings.hh>

#include "Types.hpp"
#include "WindowManager.hpp"

static phosg::PrefixedLogger em_log("[EventManager] ");

static constexpr uint16_t EVMOD_RIGHT_CONTROL_KEY_DOWN = 0x8000;
static constexpr uint16_t EVMOD_RIGHT_OPTION_KEY_DOWN = 0x4000;
static constexpr uint16_t EVMOD_RIGHT_SHIFT_KEY_DOWN = 0x2000;
static constexpr uint16_t EVMOD_CONTROL_KEY_DOWN = 0x1000;
static constexpr uint16_t EVMOD_OPTION_KEY_DOWN = 0x0800;
static constexpr uint16_t EVMOD_CAPS_LOCK_ENABLED = 0x0400;
static constexpr uint16_t EVMOD_SHIFT_KEY_DOWN = 0x0200;
static constexpr uint16_t EVMOD_COMMAND_KEY_DOWN = 0x0100;
static constexpr uint16_t EVMOD_MOUSE_BUTTON_UP = 0x0080;
static constexpr uint16_t EVMOD_WINDOW_ACTIVATED = 0x0001;

static const std::unordered_map<SDL_Keycode, uint16_t> mac_vk_code_for_sdl_keycode({
    // This maps SDL key codes to Classic Mac OS virtual key codes. (Note that
    // these are not the same as hardware key codes; those are generally hidden
    // from the application.) The extracted system KCHR (below) is used to map
    // these to ASCII and Mac Roman character codes.

    // Top row of extended keyboard
    {SDLK_ESCAPE, 0x35},
    {SDLK_F1, 0x7A},
    {SDLK_F2, 0x78},
    {SDLK_F3, 0x63},
    {SDLK_F4, 0x76},
    {SDLK_F5, 0x60},
    {SDLK_F6, 0x61},
    {SDLK_F7, 0x62},
    {SDLK_F8, 0x64},
    {SDLK_F9, 0x65},
    {SDLK_F10, 0x6D},
    {SDLK_F11, 0x67},
    {SDLK_F12, 0x6F},
    {SDLK_F13, 0x69},
    {SDLK_F14, 0x6B},
    {SDLK_F15, 0x71},

    // Numerals and symbols row
    {SDLK_GRAVE, 0x32},
    {SDLK_1, 0x12},
    {SDLK_EXCLAIM, 0x12},
    {SDLK_2, 0x13},
    {SDLK_AT, 0x13},
    {SDLK_3, 0x14},
    {SDLK_HASH, 0x14},
    {SDLK_4, 0x15},
    {SDLK_DOLLAR, 0x15},
    {SDLK_5, 0x17},
    {SDLK_PERCENT, 0x17},
    {SDLK_6, 0x16},
    {SDLK_CARET, 0x16},
    {SDLK_7, 0x1A},
    {SDLK_AMPERSAND, 0x1A},
    {SDLK_8, 0x1C},
    {SDLK_ASTERISK, 0x1C},
    {SDLK_9, 0x19},
    {SDLK_LEFTPAREN, 0x19},
    {SDLK_0, 0x1D},
    {SDLK_RIGHTPAREN, 0x1D},
    {SDLK_MINUS, 0x1B},
    {SDLK_UNDERSCORE, 0x1B},
    {SDLK_EQUALS, 0x18},
    {SDLK_PLUS, 0x18},
    {SDLK_BACKSPACE, MAC_VK_BACKSPACE},
    {SDLK_INSERT, 0x72},
    {SDLK_HELP, 0x72},
    {SDLK_HOME, 0x73},
    {SDLK_PAGEUP, 0x74},
    {SDLK_NUMLOCKCLEAR, 0x47},
    {SDLK_KP_EQUALS, 0x51},
    {SDLK_KP_DIVIDE, 0x4B},
    {SDLK_KP_MULTIPLY, 0x43},

    // First alphabet row
    {SDLK_TAB, 0x30},
    {SDLK_Q, 0x0C},
    {SDLK_W, 0x0D},
    {SDLK_E, 0x0E},
    {SDLK_R, 0x0F},
    {SDLK_T, 0x11},
    {SDLK_Y, 0x10},
    {SDLK_U, 0x20},
    {SDLK_I, 0x22},
    {SDLK_O, 0x1F},
    {SDLK_P, 0x23},
    {SDLK_LEFTBRACKET, 0x21},
    {SDLK_RIGHTBRACKET, 0x1E},
    {SDLK_BACKSLASH, 0x2A},
    {SDLK_DELETE, 0x75},
    {SDLK_END, 0x77},
    {SDLK_PAGEDOWN, 0x79},
    {SDLK_KP_7, 0x59},
    {SDLK_KP_8, 0x5B},
    {SDLK_KP_9, 0x5C},
    {SDLK_KP_MINUS, 0x4E},

    // Second alphabet row
    {SDLK_A, 0x00},
    {SDLK_S, 0x01},
    {SDLK_D, 0x02},
    {SDLK_F, 0x03},
    {SDLK_G, 0x05},
    {SDLK_H, 0x04},
    {SDLK_J, 0x26},
    {SDLK_K, 0x28},
    {SDLK_L, 0x25},
    {SDLK_SEMICOLON, 0x29},
    {SDLK_COLON, 0x29},
    {SDLK_APOSTROPHE, 0x27},
    {SDLK_DBLAPOSTROPHE, 0x27},
    {SDLK_RETURN, 0x24},
    {SDLK_KP_4, 0x56},
    {SDLK_KP_5, 0x57},
    {SDLK_KP_6, 0x58},
    {SDLK_KP_PLUS, 0x45},

    // Third alphabet row
    {SDLK_Z, 0x06},
    {SDLK_X, 0x07},
    {SDLK_C, 0x08},
    {SDLK_V, 0x09},
    {SDLK_B, 0x0B},
    {SDLK_N, 0x2D},
    {SDLK_M, 0x2E},
    {SDLK_COMMA, 0x2B},
    {SDLK_LESS, 0x2B},
    {SDLK_PERIOD, 0x2F},
    {SDLK_GREATER, 0x2F},
    {SDLK_SLASH, 0x2C},
    {SDLK_QUESTION, 0x2C},
    {SDLK_UP, 0x7E},
    {SDLK_KP_1, 0x53},
    {SDLK_KP_2, 0x54},
    {SDLK_KP_3, 0x55},
    {SDLK_KP_ENTER, 0x4C},

    // Bottom row
    {SDLK_SPACE, 0x31},
    {SDLK_LEFT, 0x7B},
    {SDLK_DOWN, 0x7D},
    {SDLK_RIGHT, 0x7C},
    {SDLK_KP_0, 0x52},
    {SDLK_KP_PERIOD, 0x41},
});

// The following tables were extracted with resource_dasm from the resource
// fork of the Mac OS System file (KCHR 0)

// clang-format off
std::array<uint8_t, 0x100> kchr_0_modifiers_table{
    0, 0, 1, 0, 2, 0, 1, 0, 3, 6, 4, 4, 5, 6, 4, 4,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    1, 0, 1, 0, 1, 0, 1, 0, 4, 4, 4, 4, 4, 4, 4, 4,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    3, 6, 4, 4, 5, 6, 4, 4, 3, 6, 4, 4, 5, 6, 4, 4,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
};

std::array<std::array<uint8_t, 0x80>, 8> kchr_0_tables{{
  {
    0x61, 0x73, 0x64, 0x66, 0x68, 0x67, 0x7A, 0x78, 0x63, 0x76, 0xA4, 0x62, 0x71, 0x77, 0x65, 0x72,
    0x79, 0x74, 0x31, 0x32, 0x33, 0x34, 0x36, 0x35, 0x3D, 0x39, 0x37, 0x2D, 0x38, 0x30, 0x5D, 0x6F,
    0x75, 0x5B, 0x69, 0x70, 0x0D, 0x6C, 0x6A, 0x27, 0x6B, 0x3B, 0x5C, 0x2C, 0x2F, 0x6E, 0x6D, 0x2E,
    0x09, 0x20, 0x60, 0x08, 0x03, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2E, 0x1D, 0x2A, 0x00, 0x2B, 0x1C, 0x1B, 0x1F, 0x00, 0x00, 0x2F, 0x03, 0x1E, 0x2D, 0x00,
    0x00, 0x3D, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00, 0x38, 0x39, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x05, 0x01, 0x0B, 0x7F, 0x10, 0x04, 0x10, 0x0C, 0x10, 0x1C, 0x1D, 0x1F, 0x1E, 0x00,
  }, {
    0x41, 0x53, 0x44, 0x46, 0x48, 0x47, 0x5A, 0x58, 0x43, 0x56, 0xB1, 0x42, 0x51, 0x57, 0x45, 0x52,
    0x59, 0x54, 0x21, 0x40, 0x23, 0x24, 0x5E, 0x25, 0x2B, 0x28, 0x26, 0x5F, 0x2A, 0x29, 0x7D, 0x4F,
    0x55, 0x7B, 0x49, 0x50, 0x0D, 0x4C, 0x4A, 0x22, 0x4B, 0x3A, 0x7C, 0x3C, 0x3F, 0x4E, 0x4D, 0x3E,
    0x09, 0x20, 0x7E, 0x08, 0x03, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2E, 0x2A, 0x2A, 0x00, 0x2B, 0x2B, 0x1B, 0x3D, 0x00, 0x00, 0x2F, 0x03, 0x2F, 0x2D, 0x00,
    0x00, 0x3D, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00, 0x38, 0x39, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x05, 0x01, 0x0B, 0x7F, 0x10, 0x04, 0x10, 0x0C, 0x10, 0x1C, 0x1D, 0x1F, 0x1E, 0x00,
  }, {
    0x41, 0x53, 0x44, 0x46, 0x48, 0x47, 0x5A, 0x58, 0x43, 0x56, 0xA4, 0x42, 0x51, 0x57, 0x45, 0x52,
    0x59, 0x54, 0x31, 0x32, 0x33, 0x34, 0x36, 0x35, 0x3D, 0x39, 0x37, 0x2D, 0x38, 0x30, 0x5D, 0x4F,
    0x55, 0x5B, 0x49, 0x50, 0x0D, 0x4C, 0x4A, 0x27, 0x4B, 0x3B, 0x5C, 0x2C, 0x2F, 0x4E, 0x4D, 0x2E,
    0x09, 0x20, 0x60, 0x08, 0x03, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2E, 0x1D, 0x2A, 0x00, 0x2B, 0x1C, 0x1B, 0x1F, 0x00, 0x00, 0x2F, 0x03, 0x1E, 0x2D, 0x00,
    0x00, 0x3D, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00, 0x38, 0x39, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x05, 0x01, 0x0B, 0x7F, 0x10, 0x04, 0x10, 0x0C, 0x10, 0x1C, 0x1D, 0x1F, 0x1E, 0x00,
  }, {
    0x8C, 0xA7, 0xB6, 0xC4, 0xFA, 0xA9, 0xBD, 0xC5, 0x8D, 0xC3, 0xA4, 0xBA, 0xCF, 0xB7, 0x00, 0xA8,
    0xB4, 0xA0, 0xC1, 0xAA, 0xA3, 0xA2, 0xA4, 0xB0, 0xAD, 0xBB, 0xA6, 0xD0, 0xA5, 0xBC, 0xD4, 0xBF,
    0x00, 0xD2, 0x00, 0xB9, 0x0D, 0xC2, 0xC6, 0xBE, 0xFB, 0xC9, 0xC7, 0xB2, 0xD6, 0x00, 0xB5, 0xB3,
    0x09, 0xCA, 0x00, 0x08, 0x03, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2E, 0x1D, 0x2A, 0x00, 0x2B, 0x1C, 0x1B, 0x1F, 0x00, 0x00, 0x2F, 0x03, 0x1E, 0x2D, 0x00,
    0x00, 0x3D, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00, 0x38, 0x39, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x05, 0x01, 0x0B, 0x7F, 0x10, 0x04, 0x10, 0x0C, 0x10, 0x1C, 0x1D, 0x1F, 0x1E, 0x00,
  }, {
    0x81, 0xEA, 0xEB, 0xEC, 0xEE, 0xFD, 0xFC, 0xFE, 0x82, 0xD7, 0xB1, 0xF5, 0xCE, 0xE3, 0xAB, 0xE4,
    0xE7, 0xFF, 0xDA, 0xDB, 0xDC, 0xDD, 0xDF, 0xDE, 0xB1, 0xE1, 0xE0, 0xD1, 0xA1, 0xE2, 0xD5, 0xAF,
    0xAC, 0xD3, 0xF6, 0xB8, 0x0D, 0xF1, 0xEF, 0xAE, 0xF0, 0xF2, 0xC8, 0xF8, 0xC0, 0xF7, 0xE5, 0xF9,
    0x09, 0xCA, 0x60, 0x08, 0x03, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2E, 0x2A, 0x2A, 0x00, 0x2B, 0x2B, 0x1B, 0x3D, 0x00, 0x00, 0x2F, 0x03, 0x2F, 0x2D, 0x00,
    0x00, 0x3D, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00, 0x38, 0x39, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x05, 0x01, 0x0B, 0x7F, 0x10, 0x04, 0x10, 0x0C, 0x10, 0x1C, 0x1D, 0x1F, 0x1E, 0x00,
  }, {
    0x81, 0xEA, 0xEB, 0xEC, 0xEE, 0xA9, 0xBD, 0xC5, 0x82, 0xC3, 0xA4, 0xF5, 0xCE, 0xB7, 0xAB, 0xA8,
    0xE7, 0xA0, 0xC1, 0xAA, 0xA3, 0xA2, 0xA4, 0xB0, 0xAD, 0xBB, 0xA6, 0xD0, 0xA5, 0xBC, 0xD4, 0xAF,
    0xAC, 0xD2, 0xF6, 0xB8, 0x0D, 0xF1, 0xEF, 0xAE, 0xFB, 0xC9, 0xC7, 0xB2, 0xD6, 0xF7, 0xE5, 0xB3,
    0x09, 0xCA, 0x60, 0x08, 0x03, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2E, 0x1D, 0x2A, 0x00, 0x2B, 0x1C, 0x1B, 0x1F, 0x00, 0x00, 0x2F, 0x03, 0x1E, 0x2D, 0x00,
    0x00, 0x3D, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00, 0x38, 0x39, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x05, 0x01, 0x0B, 0x7F, 0x10, 0x04, 0x10, 0x0C, 0x10, 0x1C, 0x1D, 0x1F, 0x1E, 0x00,
  }, {
    0x8C, 0xA7, 0xB6, 0xC4, 0xFA, 0xA9, 0xBD, 0xC5, 0x8D, 0xC3, 0xA4, 0xBA, 0xCF, 0xB7, 0xAB, 0xA8,
    0xB4, 0xA0, 0xC1, 0xAA, 0xA3, 0xA2, 0xA4, 0xB0, 0xAD, 0xBB, 0xA6, 0xD0, 0xA5, 0xBC, 0xD4, 0xBF,
    0xAC, 0xD2, 0x5E, 0xB9, 0x0D, 0xC2, 0xC6, 0xBE, 0xFB, 0xC9, 0xC7, 0xB2, 0xD6, 0x7E, 0xB5, 0xB3,
    0x09, 0xCA, 0x60, 0x08, 0x03, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2E, 0x1D, 0x2A, 0x00, 0x2B, 0x1C, 0x1B, 0x1F, 0x00, 0x00, 0x2F, 0x03, 0x1E, 0x2D, 0x00,
    0x00, 0x3D, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00, 0x38, 0x39, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x05, 0x01, 0x0B, 0x7F, 0x10, 0x04, 0x10, 0x0C, 0x10, 0x1C, 0x1D, 0x1F, 0x1E, 0x00,
  }, {
    0x01, 0x13, 0x04, 0x06, 0x08, 0x07, 0x1A, 0x18, 0x03, 0x16, 0x30, 0x02, 0x11, 0x17, 0x05, 0x12,
    0x19, 0x14, 0x31, 0x32, 0x33, 0x34, 0x36, 0x35, 0x3D, 0x39, 0x37, 0x1F, 0x38, 0x30, 0x1D, 0x0F,
    0x15, 0x1B, 0x09, 0x10, 0x0D, 0x0C, 0x0A, 0x27, 0x0B, 0x3B, 0x1C, 0x2C, 0x2F, 0x0E, 0x0D, 0x2E,
    0x09, 0x20, 0x60, 0x08, 0x03, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2E, 0x1D, 0x2A, 0x00, 0x2B, 0x1C, 0x1B, 0x1F, 0x00, 0x00, 0x2F, 0x03, 0x1E, 0x2D, 0x00,
    0x00, 0x3D, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00, 0x38, 0x39, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x05, 0x01, 0x0B, 0x7F, 0x10, 0x04, 0x10, 0x0C, 0x10, 0x1C, 0x1D, 0x1F, 0x1E, 0x00,
  },
}};
// clang-format on

static uint32_t mac_message_for_sdl_key_code(SDL_Keycode key, uint16_t modifier_flags) {
  uint8_t virtual_keycode;
  try {
    virtual_keycode = mac_vk_code_for_sdl_keycode.at(key);
  } catch (const std::out_of_range&) {
    return 0;
  }

  size_t table_index = kchr_0_modifiers_table[(modifier_flags >> 8) & 0xFF];
  uint8_t char_code = kchr_0_tables.at(table_index).at(virtual_keycode);
  return (virtual_keycode << 8) | char_code;
}

uint8_t mac_vk_from_message(uint32_t message) {
  return (uint8_t)(message >> 8);
}

class EventManager {
public:
  EventManager() = default;
  ~EventManager() = default;

  void flush_events() {
    this->enqueue_pending_events(0);
    this->event_queue.clear();
  }

  EventRecord get_next_event(uint32_t wait_ms) {
    this->enqueue_pending_events(wait_ms);
    if (this->event_queue.empty()) {
      return this->make_null_event();
    } else {
      EventRecord ev = this->event_queue.front();
      this->event_queue.pop_front();
      return ev;
    }
  }

  void push_menu_event(int16_t menu_id, int16_t item_id) {
    Point where = {static_cast<int16_t>(-menu_id), static_cast<int16_t>(-item_id)};
    this->event_queue.emplace_back(EventRecord{mouseDown, 0, 0, where, 0});
  }

  void reset_mouse_state() {
    this->modifier_flags |= EVMOD_MOUSE_BUTTON_UP;
  }

  inline const Point& get_mouse_loc() const {
    return this->mouse_loc;
  }
  inline bool is_mouse_button_down() {
    // There is at least one place where Realmz busy-loops calling Button
    // (which returns true if the mouse button is down) but does not process
    // events between those calls. In our implementation, we must process
    // events to detect any state change in the mouse button, so we do so here
    this->enqueue_pending_events(0);
    return !(this->modifier_flags & EVMOD_MOUSE_BUTTON_UP);
  }
  bool any_mouse_events_pending() const {
    for (const auto& ev : this->event_queue) {
      if (ev.what == mouseUp || ev.what == mouseDown) {
        return true;
      }
    }
    return false;
  }

protected:
  Point mouse_loc = {0, 0};
  uint16_t modifier_flags = EVMOD_MOUSE_BUTTON_UP | EVMOD_WINDOW_ACTIVATED;
  std::deque<EventRecord> event_queue;

  void set_modifier_value(uint16_t what, bool enabled) {
    if (enabled) {
      this->modifier_flags |= what;
    } else {
      this->modifier_flags &= ~what;
    }
  }

  EventRecord make_null_event() const {
    return {
        .what = nullEvent,
        .message = 0,
        .when = TickCount(),
        .where = this->mouse_loc,
        .modifiers = this->modifier_flags,
    };
  }

  void enqueue_event(uint16_t what, uint32_t message, void* window_port, const char* text) {
    auto& ev = this->event_queue.emplace_back();
    ev.what = what;
    ev.message = message;
    ev.when = TickCount();
    ev.where = this->mouse_loc;
    ev.modifiers = this->modifier_flags;
    ev.window_port = window_port;
    if (text && strlen(text)) {
      strcpy(ev.text, text);
    }

#ifdef REALMZ_DEBUG
    // Debugging features: the backslash key switches all windows to partially-transparent to debug compositing issues;
    // this makes rendering much slower since it recomposites and alpha-blends all windows every time
    if ((ev.what == keyDown) && ((ev.message & 0xFF) == static_cast<uint8_t>('\\'))) {
      WindowManager::instance().on_debug_signal();
    }
#endif
  }

  void enqueue_sdl_event(const SDL_Event& e) {
    switch (e.type) {
      // TODO: Handle any cleanup of specific window that was closed
      //  case SDL_EVENT_WINDOW_CLOSE_REQUESTED:
      case SDL_EVENT_QUIT:
        exit(EXIT_SUCCESS);
        break;
      case SDL_EVENT_KEY_DOWN:
      case SDL_EVENT_KEY_UP: {
        em_log.info_f("{} mod={:04X} key={:08X}",
            (e.type == SDL_EVENT_KEY_UP) ? "SDL_EVENT_KEY_UP" : "SDL_EVENT_KEY_DOWN",
            e.key.mod, e.key.key);
        this->set_modifier_value(EVMOD_RIGHT_CONTROL_KEY_DOWN, e.key.mod & SDL_KMOD_RCTRL);
        this->set_modifier_value(EVMOD_RIGHT_OPTION_KEY_DOWN, e.key.mod & SDL_KMOD_RALT);
        this->set_modifier_value(EVMOD_RIGHT_SHIFT_KEY_DOWN, e.key.mod & SDL_KMOD_RSHIFT);
        this->set_modifier_value(EVMOD_CONTROL_KEY_DOWN, e.key.mod & SDL_KMOD_LCTRL);
        this->set_modifier_value(EVMOD_OPTION_KEY_DOWN, e.key.mod & SDL_KMOD_LALT);
        this->set_modifier_value(EVMOD_CAPS_LOCK_ENABLED, e.key.mod & SDL_KMOD_CAPS);
        this->set_modifier_value(EVMOD_SHIFT_KEY_DOWN, e.key.mod & SDL_KMOD_LSHIFT);
        this->set_modifier_value(EVMOD_COMMAND_KEY_DOWN, e.key.mod & SDL_KMOD_GUI);

        uint32_t message = mac_message_for_sdl_key_code(e.key.key, this->modifier_flags);
        if (message != 0) {
          // TODO: Do keyboard events always go to the front window, or is
          // there some notion of keyboard focus in Classic Mac OS?
          this->enqueue_event((e.type == SDL_EVENT_KEY_DOWN) ? keyDown : keyUp, message, FrontWindow(), "");
        } else {
          em_log.warning_f("Unknown key pressed: key=0x{:X} scancode=0x{:X}",
              static_cast<size_t>(e.key.key), static_cast<size_t>(e.key.scancode));
        }
        break;
      }
      case SDL_EVENT_MOUSE_MOTION:
        // Classic Mac OS doesn't have a mouse motion event, so we just track
        // the location and ignore it otherwise
        this->mouse_loc.h = e.motion.x;
        this->mouse_loc.v = e.motion.y;
        break;
      case SDL_EVENT_MOUSE_BUTTON_DOWN:
      case SDL_EVENT_MOUSE_BUTTON_UP:
        em_log.info_f("{} {} {} {:g} {:g}",
            (e.type == SDL_EVENT_MOUSE_BUTTON_UP) ? "SDL_EVENT_MOUSE_BUTTON_UP" : "SDL_EVENT_MOUSE_BUTTON_DOWN",
            e.button.button, e.button.clicks, e.button.x, e.button.y);
        // Ignore events for all mouse buttons except the primary (left) button
        if (e.button.button == 1) {
          this->mouse_loc.h = e.button.x;
          this->mouse_loc.v = e.button.y;
          this->set_modifier_value(EVMOD_MOUSE_BUTTON_UP, (e.type == SDL_EVENT_MOUSE_BUTTON_UP));
          auto window = WindowManager::instance().window_for_point(this->mouse_loc.h, this->mouse_loc.v);
          this->enqueue_event((e.type == SDL_EVENT_MOUSE_BUTTON_DOWN) ? mouseDown : mouseUp, 0, window ? &window->get_port() : nullptr, "");
        }
        break;
      case SDL_EVENT_TEXT_EDITING:
      case SDL_EVENT_TEXT_INPUT:
        em_log.info_f("{} {}",
            (e.type == SDL_EVENT_TEXT_EDITING) ? "SDL_EVENT_TEXT_EDITING" : "SDL_EVENT_TEXT_INPUT", e.text.text);

        // We can use the otherwise unused app4Evt to signal a text input event, the handling of which
        // would originally have been intercepted and processed by TextEdit.
        // TODO: Do keyboard events always go to the front window, or is
        // there some notion of keyboard focus in Classic Mac OS?
        this->enqueue_event(app4Evt, 0, FrontWindow(), e.text.text);
        break;
      default:
        em_log.info_f("Unhandled SDL event type 0x{:X}", e.type);
    }
  }

  void enqueue_pending_events(int32_t wait_ms) {
    SDL_Event e;

    // If wait_ms > 0, wait for at least one event to be available before
    // enqueuing all remaining events
    if ((wait_ms > 0) && SDL_WaitEventTimeout(&e, wait_ms)) {
      this->enqueue_sdl_event(e);
    }
    while (SDL_PollEvent(&e)) {
      this->enqueue_sdl_event(e);
    }
  }
};

EventManager em;

uint32_t TickCount(void) {
  return (clock() * 60) / CLOCKS_PER_SEC;
}

uint32_t GetDblTime(void) {
  // On Classic Mac OS, the double-click time was configurable; we just set it
  // to 1/3 of a second here.
  return 20;
}

void SystemTask(void) {
  // Realmz uses GetNextEvent in hot loops in several places, but it also calls
  // SystemTask in those loops. There's nothing for SystemTask to do on modern
  // systems since we now have preemptive multitasking, but we can use this
  // function to make the hot loops a bit less hot by sleeping for a CPU time
  // slice or two.
  SDL_Delay(10);
}

void FlushEvents(int16_t which_mask, uint16_t stop_mask) {
  // Realmz only calls this with which_mask = everyEvent and stop_mask = 0, so
  // we don't bother to implement filtering.
  if (which_mask != everyEvent) {
    throw std::logic_error(std::format("which_mask ({:04X}) masks out some events in FlushEvents", which_mask));
  }
  if (stop_mask != 0) {
    throw std::logic_error("stop_mask specifies some events");
  }

  em.flush_events();
}

Boolean GetNextEvent(int16_t which_mask, EventRecord* ret) {
  // Realmz only calls this with which_mask = everyEvent, so we don't bother to
  // implement filtering.
  if (which_mask != everyEvent) {
    throw std::logic_error(std::format("which_mask ({:04X}) masks out some events in GetNextEvent", which_mask));
  }

  *ret = em.get_next_event(0);
  return (ret->what != nullEvent);
}

Boolean WaitNextEvent(int16_t which_mask, EventRecord* ret, uint32_t sleep, RgnHandle mouse_rgn) {
  // Realmz doesn't use mask, sleep, or mouse_rgn (thankfully, since mouse_rgn
  // would be annoying to implement!)
  if (which_mask != everyEvent) {
    throw std::logic_error(std::format("which_mask ({:04X}) masks out some events in WaitNextEvent", which_mask));
  }
  if (mouse_rgn) {
    throw std::logic_error("mouse_rgn must be null");
  }

  *ret = em.get_next_event(sleep);
  return (ret->what != nullEvent);
}

void GetMouse(Point* ret) {
  *ret = em.get_mouse_loc();

  // GetMouse isn't actually an Event Manager function... it's a QuickDraw
  // function! So, unlike the rest of the Event Manager, it returns coordinates
  // local to the current graphics port.
  auto port = CCGrafPort::as_port(qd.thePort);
  if (port) {
    *ret = port->to_local_space(*ret);
  }
}

void GetMouseGlobal(Point* ret) {
  *ret = em.get_mouse_loc();
}

Boolean Button(void) {
  return em.is_mouse_button_down();
}

Boolean StillDown(void) {
  return em.is_mouse_button_down() && !em.any_mouse_events_pending();
}

void PushMenuEvent(int16_t menu_id, int16_t item_id) {
  em.push_menu_event(menu_id, item_id);
}

void reset_mouse_state() {
  em.reset_mouse_state();
}
